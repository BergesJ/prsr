
==================== FINAL INTERFACE ====================
2016-05-24 12:01:27.554207 UTC

interface prsr_KeI5IJaG2ym2Eek28fTvTe:Lib 7103
  interface hash: a39c601091b935c2c3460f380effe6b3
  ABI hash: 64460d68131d34427bc773650658da33
  export-list hash: 7005306bde323a4949fcdc282a4f9a08
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 962af636f8e927040c7daa9c21457292
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.ssvParser
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:System.IO 0248c1e850b7ea124cf7a2e1669ebf67
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
37956d35d9491df7b2ee7643285be5fe
  $fAlternativeParser :: Lib.Alternative Lib.Parser
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Parser
                  Lib.$fApplicativeParser
                  Lib.$fAlternativeParser_$cmzero
                  Lib.$fAlternativeParser_$c<|> -}
cfa7c12c0e94513ea937b08353cb2bd1
  $fAlternativeParser1 ::
    Lib.Parser a
    -> Lib.Parser a -> GHC.Base.String -> [(a, GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs, Strictness: <C(S),C(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a15
                   p1 :: Lib.Parser a15
                   p2 :: Lib.Parser a15
                   xs :: GHC.Base.String ->
                 case p1 `cast` (Lib.NTCo:Parser[0] <a15>_R) xs of wild {
                   [] -> p2 `cast` (Lib.NTCo:Parser[0] <a15>_R) xs
                   : ipv ipv1 -> p1 `cast` (Lib.NTCo:Parser[0] <a15>_R) xs }) -}
76086434c3b605d943cfa817c9c41d12
  $fAlternativeParser2 :: GHC.Base.String -> [(a, GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a15 cs :: GHC.Base.String ->
                 GHC.Types.[] @ (a15, GHC.Base.String)) -}
5ead4664020fc161a04d7fdac7930989
  $fAlternativeParser_$c<|> ::
    Lib.Parser a -> Lib.Parser a -> Lib.Parser a
  {- Arity: 3, HasNoCafRefs, Strictness: <C(S),C(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.$fAlternativeParser1
                  `cast`
                (forall a15.
                 <Lib.Parser a15>_R
                 ->_R <Lib.Parser a15>_R
                 ->_R Sym (Lib.NTCo:Parser[0] <a15>_R)) -}
202600247132a5be7850918ce2f2371d
  $fAlternativeParser_$cmzero :: Lib.Parser a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                Lib.$fAlternativeParser2
                  `cast`
                (forall a15. Sym (Lib.NTCo:Parser[0] <a15>_R)) -}
d4b8466a2f325daff855458c725512f6
  $fApplicativeParser :: GHC.Base.Applicative Lib.Parser
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Parser
                  Lib.$fFunctorParser
                  Lib.$fApplicativeParser_$cpure
                  Lib.$fApplicativeParser_$c<*>
                  Lib.$fApplicativeParser_$c*>
                  Lib.$fApplicativeParser_$c<* -}
d4b8466a2f325daff855458c725512f6
  $fApplicativeParser1 ::
    Lib.Parser a
    -> Lib.Parser b -> GHC.Base.String -> [(a, GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: (\ @ a15
                   @ b
                   eta :: Lib.Parser a15
                   eta1 :: Lib.Parser b
                   eta2 :: GHC.Base.String ->
                 Lib.$fApplicativeParser3
                   @ b
                   @ a15
                   (\ cs :: GHC.Base.String[OneShot] ->
                    Lib.$fApplicativeParser2
                      @ a15
                      @ b
                      (eta `cast` (Lib.NTCo:Parser[0] <a15>_R) cs))
                     `cast`
                   (Sym (Lib.NTCo:Parser[0] <b -> a15>_R))
                   eta1
                   eta2) -}
1d0472a76a50532893cb77ab6e616800
  $fApplicativeParser2 ::
    [(a, GHC.Base.String)] -> [(b -> a, GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
d4b8466a2f325daff855458c725512f6
  $fApplicativeParser3 ::
    Lib.Parser (a -> b)
    -> Lib.Parser a -> GHC.Base.String -> [(b, GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: (\ @ a15
                   @ b
                   p :: Lib.Parser (a15 -> b)
                   q :: Lib.Parser a15
                   cs :: GHC.Base.String ->
                 let {
                   lvl25 :: [(a15, GHC.Base.String)]
                   = q `cast` (Lib.NTCo:Parser[0] <a15>_R) cs
                 } in
                 letrec {
                   go8 :: [(a15 -> b, GHC.Base.String)] -> [(b, GHC.Base.String)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [(a15 -> b, GHC.Base.String)] ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ (b, GHC.Base.String)
                       : y ys
                       -> case y of wild1 { (,) f cs' ->
                          let {
                            z :: [(b, GHC.Base.String)] = go8 ys
                          } in
                          letrec {
                            go9 :: [(a15, GHC.Base.String)] -> [(b, GHC.Base.String)]
                              {- Arity: 1, Strictness: <S,1*U> -}
                            = \ ds1 :: [(a15, GHC.Base.String)] ->
                              case ds1 of wild2 {
                                [] -> z
                                : y1 ys1
                                -> case y1 of wild3 { (,) a16 cs'1 ->
                                   GHC.Types.: @ (b, GHC.Base.String) (f a16, cs'1) (go9 ys1) } }
                          } in
                          go9 lvl25 } }
                 } in
                 go8 (p `cast` (Lib.NTCo:Parser[0] <a15 -> b>_R) cs)) -}
d4b8466a2f325daff855458c725512f6
  $fApplicativeParser4 ::
    Lib.Parser a
    -> Lib.Parser b -> GHC.Base.String -> [(b, GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a15
                   @ b
                   eta :: Lib.Parser a15
                   eta1 :: Lib.Parser b
                   eta2 :: GHC.Base.String ->
                 Lib.$fApplicativeParser3
                   @ b
                   @ b
                   (Lib.$fApplicativeParser5 @ (b -> b) @ a15 (GHC.Base.id @ b) eta)
                     `cast`
                   (Sym (Lib.NTCo:Parser[0] <b -> b>_R))
                   eta1
                   eta2) -}
d4b8466a2f325daff855458c725512f6
  $fApplicativeParser5 ::
    a -> Lib.Parser b -> GHC.Base.String -> [(a, GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)><L,U>,
     Unfolding: (\ @ a15
                   @ b
                   eta :: a15
                   eta1 :: Lib.Parser b
                   eta2 :: GHC.Base.String ->
                 letrec {
                   go8 :: [(b, GHC.Base.String)] -> [(a15, GHC.Base.String)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [(b, GHC.Base.String)] ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ (a15, GHC.Base.String)
                       : y ys
                       -> case y of wild1 { (,) a16 cs' ->
                          GHC.Types.: @ (a15, GHC.Base.String) (eta, cs') (go8 ys) } }
                 } in
                 go8 (eta1 `cast` (Lib.NTCo:Parser[0] <b>_R) eta2)) -}
169a15f1d43482cbd1d148c341b7411b
  $fApplicativeParser6 ::
    a -> GHC.Base.String -> [(a, GHC.Base.String)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ a15 a16 :: a15 cs :: GHC.Base.String ->
                 GHC.Types.:
                   @ (a15, GHC.Base.String)
                   (a16, cs)
                   (GHC.Types.[] @ (a15, GHC.Base.String))) -}
d4b8466a2f325daff855458c725512f6
  $fApplicativeParser_$c*> ::
    Lib.Parser a -> Lib.Parser b -> Lib.Parser b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.$fApplicativeParser4
                  `cast`
                (forall a15 b.
                 <Lib.Parser a15>_R
                 ->_R <Lib.Parser b>_R
                 ->_R Sym (Lib.NTCo:Parser[0] <b>_R)) -}
d4b8466a2f325daff855458c725512f6
  $fApplicativeParser_$c<* ::
    Lib.Parser a -> Lib.Parser b -> Lib.Parser a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.$fApplicativeParser1
                  `cast`
                (forall a15 b.
                 <Lib.Parser a15>_R
                 ->_R <Lib.Parser b>_R
                 ->_R Sym (Lib.NTCo:Parser[0] <a15>_R)) -}
d4b8466a2f325daff855458c725512f6
  $fApplicativeParser_$c<*> ::
    Lib.Parser (a -> b) -> Lib.Parser a -> Lib.Parser b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.$fApplicativeParser3
                  `cast`
                (forall a15 b.
                 <Lib.Parser (a15 -> b)>_R
                 ->_R <Lib.Parser a15>_R
                 ->_R Sym (Lib.NTCo:Parser[0] <b>_R)) -}
d4b8466a2f325daff855458c725512f6
  $fApplicativeParser_$cpure :: a -> Lib.Parser a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Unfolding: InlineRule (0, True, True)
                Lib.$fApplicativeParser6
                  `cast`
                (forall a15. <a15>_R ->_R Sym (Lib.NTCo:Parser[0] <a15>_R)) -}
d4b8466a2f325daff855458c725512f6
  $fFunctorParser :: GHC.Base.Functor Lib.Parser
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Parser Lib.$fFunctorParser_$cfmap Lib.$fFunctorParser_$c<$ -}
d4b8466a2f325daff855458c725512f6
  $fFunctorParser1 ::
    (a -> b)
    -> Lib.Parser a -> GHC.Base.String -> [(b, GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(U)><C(S),1*C1(U)><L,U>,
     Unfolding: (\ @ a15
                   @ b
                   f :: a15 -> b
                   p :: Lib.Parser a15
                   cs :: GHC.Base.String ->
                 letrec {
                   go8 :: [(a15, GHC.Base.String)] -> [(b, GHC.Base.String)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [(a15, GHC.Base.String)] ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ (b, GHC.Base.String)
                       : y ys
                       -> case y of wild1 { (,) a16 cs' ->
                          GHC.Types.: @ (b, GHC.Base.String) (f a16, cs') (go8 ys) } }
                 } in
                 go8 (p `cast` (Lib.NTCo:Parser[0] <a15>_R) cs)) -}
d4b8466a2f325daff855458c725512f6
  $fFunctorParser_$c<$ :: a -> Lib.Parser b -> Lib.Parser a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.$fApplicativeParser5
                  `cast`
                (forall a15 b.
                 <a15>_R
                 ->_R <Lib.Parser b>_R
                 ->_R Sym (Lib.NTCo:Parser[0] <a15>_R)) -}
d4b8466a2f325daff855458c725512f6
  $fFunctorParser_$cfmap :: (a -> b) -> Lib.Parser a -> Lib.Parser b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(U)><C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.$fFunctorParser1
                  `cast`
                (forall a15 b.
                 <a15 -> b>_R
                 ->_R <Lib.Parser a15>_R
                 ->_R Sym (Lib.NTCo:Parser[0] <b>_R)) -}
d4b8466a2f325daff855458c725512f6
  $fMonadParser :: GHC.Base.Monad Lib.Parser
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Parser
                  Lib.$fApplicativeParser
                  Lib.$fMonadParser_$c>>=
                  Lib.$fMonadParser_$c>>
                  Lib.$fApplicativeParser_$cpure
                  Lib.$fMonadParser_$s$dmfail -}
d4b8466a2f325daff855458c725512f6
  $fMonadParser1 ::
    Lib.Parser a
    -> (a -> Lib.Parser b) -> GHC.Base.String -> [(b, GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ a15
                   @ b
                   p :: Lib.Parser a15
                   f :: a15 -> Lib.Parser b
                   cs :: GHC.Base.String ->
                 letrec {
                   go8 :: [(a15, GHC.Base.String)] -> [(b, GHC.Base.String)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [(a15, GHC.Base.String)] ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ (b, GHC.Base.String)
                       : y ys
                       -> case y of wild1 { (,) a16 cs' ->
                          GHC.Base.++
                            @ (b, GHC.Base.String)
                            ((f a16) `cast` (Lib.NTCo:Parser[0] <b>_R) cs')
                            (go8 ys) } }
                 } in
                 go8 (p `cast` (Lib.NTCo:Parser[0] <a15>_R) cs)) -}
d4b8466a2f325daff855458c725512f6
  $fMonadParser_$c>> :: Lib.Parser a -> Lib.Parser b -> Lib.Parser b
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a15
                   @ b
                   m1 :: Lib.Parser a15
                   k :: Lib.Parser b
                   eta :: GHC.Base.String ->
                 (Lib.$fMonadParser_$c>>= @ a15 @ b m1 (\ ds :: a15 -> k))
                   `cast`
                 (Lib.NTCo:Parser[0] <b>_R)
                   eta)
                  `cast`
                (forall a15 b.
                 <Lib.Parser a15>_R
                 ->_R <Lib.Parser b>_R
                 ->_R Sym (Lib.NTCo:Parser[0] <b>_R)) -}
d4b8466a2f325daff855458c725512f6
  $fMonadParser_$c>>= ::
    Lib.Parser a -> (a -> Lib.Parser b) -> Lib.Parser b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.$fMonadParser1
                  `cast`
                (forall a15 b.
                 <Lib.Parser a15>_R
                 ->_R <a15 -> Lib.Parser b>_R
                 ->_R Sym (Lib.NTCo:Parser[0] <b>_R)) -}
d4b8466a2f325daff855458c725512f6
  $fMonadParser_$s$dmfail :: GHC.Base.String -> Lib.Parser a
  {- Arity: 1, Strictness: <B,U>b,
     Unfolding: InlineRule (-1, True, True)
                (\ @ a15 eta :: [GHC.Types.Char] ->
                 GHC.Err.error @ (Lib.Parser a15) eta) -}
e86eda1c8592a720b8b5a583625249c5
  $fMonadPlusParser :: Lib.MonadPlus Lib.Parser
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Parser Lib.$fMonadZeroParser Lib.$fMonadPlusParser_$cmplus -}
fc338372725372061620a35fe42a9d2d
  $fMonadPlusParser1 ::
    Lib.Parser a
    -> Lib.Parser a -> GHC.Base.String -> [(a, GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a15
                   p :: Lib.Parser a15
                   q :: Lib.Parser a15
                   cs :: GHC.Base.String ->
                 GHC.Base.augment
                   @ (a15, GHC.Base.String)
                   (\ @ b
                      c :: (a15, GHC.Base.String) -> b -> b[OneShot]
                      n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ (a15, GHC.Base.String)
                      @ b
                      c
                      n
                      (p `cast` (Lib.NTCo:Parser[0] <a15>_R) cs))
                   (q `cast` (Lib.NTCo:Parser[0] <a15>_R) cs)) -}
e955be97f565861d412b638c3c9440b1
  $fMonadPlusParser_$cmplus ::
    Lib.Parser a -> Lib.Parser a -> Lib.Parser a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.$fMonadPlusParser1
                  `cast`
                (forall a15.
                 <Lib.Parser a15>_R
                 ->_R <Lib.Parser a15>_R
                 ->_R Sym (Lib.NTCo:Parser[0] <a15>_R)) -}
8dcc607850d1327cd7214249b3cf0a23
  $fMonadZeroParser :: Lib.MonadZero Lib.Parser
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Parser Lib.$fMonadParser Lib.$fAlternativeParser_$cmzero -}
0060cf9bf1116c986cbb3b90aa5631c9
  $fShowFieldValue :: GHC.Show.Show Lib.FieldValue
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.FieldValue
                  Lib.$fShowFieldValue_$cshowsPrec
                  Lib.$fShowFieldValue_$cshow
                  Lib.$fShowFieldValue_$cshowList -}
0060cf9bf1116c986cbb3b90aa5631c9
  $fShowFieldValue1 :: Lib.FieldValue -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Lib.FieldValue w1 :: GHC.Base.String ->
                 Lib.$w$cshowsPrec 0 w w1) -}
9a7af80d7dabcb181104572290511d94
  $fShowFieldValue2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FVB {"#) -}
5cf67e4cd0b1f1c5ee2ffc6adc8229af
  $fShowFieldValue3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
fd2f677d12535936c57bacee78c66792
  $fShowFieldValue4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "value = "#) -}
6d716bd12e85840fff546ff5b64d44d4
  $fShowFieldValue5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FVQ {"#) -}
0060cf9bf1116c986cbb3b90aa5631c9
  $fShowFieldValue_$cshow :: Lib.FieldValue -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Lib.FieldValue ->
                 Lib.$fShowFieldValue_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
0060cf9bf1116c986cbb3b90aa5631c9
  $fShowFieldValue_$cshowList :: [Lib.FieldValue] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.FieldValue
                   Lib.$fShowFieldValue1) -}
0060cf9bf1116c986cbb3b90aa5631c9
  $fShowFieldValue_$cshowsPrec ::
    GHC.Types.Int -> Lib.FieldValue -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Lib.FieldValue w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Lib.$w$cshowsPrec ww1 w1 w2 }) -}
fa298b31c3655a86223a64c25617d19f
  $fShowRow :: GHC.Show.Show Lib.Row
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Row
                  Lib.$fShowRow_$cshowsPrec
                  Lib.$fShowRow_$cshow
                  Lib.$fShowRow_$cshowList -}
fa298b31c3655a86223a64c25617d19f
  $fShowRow1 :: Lib.Row -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Lib.Row w1 :: GHC.Base.String ->
                 case w of ww { Lib.Row ww1 -> Lib.$w$cshowsPrec1 0 ww1 w1 }) -}
1f42bf4e221f3978527199efde41b4f3
  $fShowRow2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "fields = "#) -}
742b39afd3902781929f975261d685b4
  $fShowRow3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Row {"#) -}
fa298b31c3655a86223a64c25617d19f
  $fShowRow_$cshow :: Lib.Row -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Lib.Row ->
                 Lib.$fShowRow_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
fa298b31c3655a86223a64c25617d19f
  $fShowRow_$cshowList :: [Lib.Row] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Lib.Row Lib.$fShowRow1) -}
fa298b31c3655a86223a64c25617d19f
  $fShowRow_$cshowsPrec :: GHC.Types.Int -> Lib.Row -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Lib.Row w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.Row ww3 ->
                 Lib.$w$cshowsPrec1 ww1 ww3 w2 } }) -}
42c90b26d7407a3f41b3c5d50bb31b31
  $fShowSSV :: GHC.Show.Show Lib.SSV
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.SSV
                  Lib.$fShowSSV_$cshowsPrec
                  Lib.$fShowSSV_$cshow
                  Lib.$fShowSSV_$cshowList -}
42c90b26d7407a3f41b3c5d50bb31b31
  $fShowSSV1 :: Lib.SSV -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Lib.SSV w1 :: GHC.Base.String ->
                 Lib.$w$cshowsPrec2 0 w w1) -}
42c90b26d7407a3f41b3c5d50bb31b31
  $fShowSSV_$cshow :: Lib.SSV -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Lib.SSV ->
                 Lib.$fShowSSV_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
42c90b26d7407a3f41b3c5d50bb31b31
  $fShowSSV_$cshowList :: [Lib.SSV] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Lib.SSV Lib.$fShowSSV1) -}
42c90b26d7407a3f41b3c5d50bb31b31
  $fShowSSV_$cshowsPrec :: GHC.Types.Int -> Lib.SSV -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Lib.SSV w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Lib.$w$cshowsPrec2 ww1 w1 w2 }) -}
c1ae5aa30dae493cf42d75ac1033f0fa
  $s$fShowEither2 ::
    Data.Either.Either [GHC.Types.Char] GHC.Types.Int -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w3 :: Data.Either.Either
                           [GHC.Types.Char] GHC.Types.Int ->
                 Data.Either.$w$cshowsPrec
                   @ [GHC.Types.Char]
                   @ GHC.Types.Int
                   GHC.Show.$fShow[]_$s$fShow[]1
                   GHC.Show.$fShowInt
                   0
                   w3) -}
0060cf9bf1116c986cbb3b90aa5631c9
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> Lib.FieldValue -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   w :: Lib.FieldValue
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   Lib.FVQ b1
                   -> let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Lib.$fShowFieldValue5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Lib.$fShowFieldValue4
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.shows6
                                  (GHC.Show.showLitString
                                     b1
                                     (GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.shows6
                                        (GHC.Base.++ @ GHC.Types.Char Lib.$fShowFieldValue3 x)))))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p w1
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1)) }
                   Lib.FVB b1
                   -> let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Lib.$fShowFieldValue2
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Lib.$fShowFieldValue4
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.shows6
                                  (GHC.Show.showLitString
                                     b1
                                     (GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.shows6
                                        (GHC.Base.++ @ GHC.Types.Char Lib.$fShowFieldValue3 x)))))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p w1
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1)) } }) -}
a652461339ee107bd5add8d3ea38ac4a
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> [Lib.FieldValue] -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: [Lib.FieldValue]
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Lib.$fShowRow3
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Lib.$fShowRow2
                          (let {
                             s :: GHC.Base.String
                             = GHC.Base.++ @ GHC.Types.Char Lib.$fShowFieldValue3 x
                           } in
                           case ww1 of wild {
                             [] -> GHC.CString.unpackAppendCString# "[]"# s
                             : x1 xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (Lib.$w$cshowsPrec
                                     0
                                     x1
                                     (let {
                                        lvl25 :: [GHC.Types.Char]
                                        = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__2 s
                                      } in
                                      letrec {
                                        showl :: [Lib.FieldValue] -> [GHC.Types.Char]
                                          {- Arity: 1, Strictness: <S,1*U> -}
                                        = \ ds2 :: [Lib.FieldValue] ->
                                          case ds2 of wild1 {
                                            [] -> lvl25
                                            : y ys
                                            -> GHC.Types.:
                                                 @ GHC.Types.Char
                                                 GHC.Show.showList__1
                                                 (Lib.$w$cshowsPrec 0 y (showl ys)) }
                                      } in
                                      showl xs)) }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
42c90b26d7407a3f41b3c5d50bb31b31
  $w$cshowsPrec2 ::
    GHC.Prim.Int# -> Lib.SSV -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0] -}
37956d35d9491df7b2ee7643285be5fe
  class GHC.Base.Applicative f => Alternative (f :: * -> *) where
    empty :: f a
    (<|>) :: f a -> f a -> f a
0060cf9bf1116c986cbb3b90aa5631c9
  data FieldValue
    = FVQ {value :: GHC.Base.String} | FVB {value :: GHC.Base.String}
e86eda1c8592a720b8b5a583625249c5
  class Lib.MonadZero m => MonadPlus (m :: * -> *) where
    mplus :: m a -> m a -> m a
8dcc607850d1327cd7214249b3cf0a23
  class GHC.Base.Monad m => MonadZero (m :: * -> *) where
    mzero :: m a
d4b8466a2f325daff855458c725512f6
  newtype Parser a
    = Parser (GHC.Base.String -> [(a, GHC.Base.String)])
fa298b31c3655a86223a64c25617d19f
  data Row = Row {fields :: [Lib.FieldValue]}
42c90b26d7407a3f41b3c5d50bb31b31
  data SSV = CSV {rows :: [Lib.Row]} | TSV {rows :: [Lib.Row]}
e24d88aa5dcabf9ed78fb61e05c20487
  fields :: Lib.Row -> [Lib.FieldValue]
  RecSel Lib.Row
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Lib.Row -> case ds of wild { Lib.Row ds1 -> ds1 }) -}
53ee9a29fde5857bde3d9fd9843521ef
  rows :: Lib.SSV -> [Lib.Row]
  RecSel Lib.SSV
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Lib.SSV ->
                 case ds of wild { Lib.CSV ds1 -> ds1 Lib.TSV ds1 -> ds1 }) -}
f9f87075578d780e46b71c72a46db80f
  ssvParser :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.ssvParser1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
83eb3be945331b8ffdcf839518c6e1cb
  ssvParser1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U> -}
62053fb4f0e050f74c17e864f4be6624
  value :: Lib.FieldValue -> GHC.Base.String
  RecSel Lib.FieldValue
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Lib.FieldValue ->
                 case ds of wild { Lib.FVQ ds1 -> ds1 Lib.FVB ds1 -> ds1 }) -}
instance Lib.Alternative [Lib.Parser] = Lib.$fAlternativeParser
instance GHC.Base.Applicative [Lib.Parser]
  = Lib.$fApplicativeParser
instance GHC.Base.Functor [Lib.Parser] = Lib.$fFunctorParser
instance GHC.Base.Monad [Lib.Parser] = Lib.$fMonadParser
instance Lib.MonadPlus [Lib.Parser] = Lib.$fMonadPlusParser
instance Lib.MonadZero [Lib.Parser] = Lib.$fMonadZeroParser
instance GHC.Show.Show [Lib.FieldValue] = Lib.$fShowFieldValue
instance GHC.Show.Show [Lib.Row] = Lib.$fShowRow
instance GHC.Show.Show [Lib.SSV] = Lib.$fShowSSV
"SPEC/Lib $dmfail @ Parser" [ALWAYS] forall $dMonad :: GHC.Base.Monad
                                                         Lib.Parser
  GHC.Base.$dmfail @ Lib.Parser $dMonad = Lib.$fMonadParser_$s$dmfail
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

